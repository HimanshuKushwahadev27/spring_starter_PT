package com.emi.api;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.emi.dto.Employee;
import com.emi.exception.ApplicationException;
import com.emi.exception.DataNotInsertedException;
import com.emi.exception.ResourceNotFoundException;
import com.emi.service.EmployeeService;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Positive;

@RestController
@RequestMapping("/employees")
public class EmployeeApi {
	
	Logger log = LoggerFactory.getLogger(EmployeeApi.class);
	private EmployeeService employeeService;
	
	
	public EmployeeApi(EmployeeService employeeService) {
		super();
		this.employeeService = employeeService;
	}
	
	@GetMapping(value="/test" , produces= {"application/xml", "application/json"})
	public Employee test() {
		return new Employee(1, "John Doe", "123 Main St", 50000);
	}
	
	@GetMapping(value= "getAllEmp" ,produces= {"application/xml", "application/json"})
	public List<Employee> getEmployees() {
		//log stores the info message in a log file instead of console
		//these are like checkpoints that helps in storage of info messages
		log.info("inside getEmployees method");
		System.out.println("before calling");
		return employeeService.getAllEmployees();
		
	}
	
	//using @requestbody to get the employee data from the http response generated by the client
	//UI(user input info) -> http request(info in the body in xml format) -> @requestbody (map the xml data to employee object)
	@PostMapping(produces={"application/json"}, consumes={"application/xml" , "application/json"})
	public ResponseEntity<String> addEmployee(@Valid @RequestBody Employee emp){
		if( employeeService.addEmployee(emp)) {
			return ResponseEntity.ok("Employee added successfully");
		}else {
			throw new DataNotInsertedException("Failed to add employee");
		}
	}
	
	@GetMapping(value="/{Id}" , produces= {"application/json"})
	public Employee getById(@PathVariable("Id") int id) {
		return employeeService.getAllEmployees().stream()
				.filter(e->e.getEmpId()==id)
				.findFirst()            
				.orElseThrow(()->new ApplicationException("Employee not found with id: "+id));
		         //Exception will be handled in GlobalException class
	}
	
	@PutMapping(value="/update/{Id}" ,produces={"application/json" , "application/xml"}, consumes={"application/xml" , "application/json"})
	public ResponseEntity<String> updateEmployee(@PathVariable @Positive int Id,@Valid @RequestBody Employee emp) {
		//in http request we will only have empName,address,salary in the body not empId
		//it is provided here in the path variable
		emp.setEmpId(Id);
		boolean flag=employeeService.updateEmployee(emp);
		if(flag) {
			return ResponseEntity.ok("Employee updated successfully");
		}
		else {
			throw new ResourceNotFoundException("Employee not found with id: "+Id);
		}
	}
	
	@DeleteMapping(value="/delete/{Id}" , produces={"application/json" , "application/xml"})
	public ResponseEntity<String> deleteEmployee(@PathVariable @Positive int Id) {
		
		boolean flag=employeeService.deleteEmployee(Id);
		if(flag) {
			return ResponseEntity.ok("Employee deleted successfully");
		}
		else {
			throw new ResourceNotFoundException("Employee not found with id: "+Id);
		}
	}
}
